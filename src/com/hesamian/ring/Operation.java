package com.hesamian.ring;

import java.lang.reflect.Method;
import java.math.BigInteger;

/**
 * This class handles Operation. Operation class and enum Type are tightly
 * coupled. It is good practice to store Operation Types as enums.
 * 
 * @author Seyedamirhossein Hesamian
 * @since 08/30/2016
 */

public class Operation {

    private enum Type {

        /**
         * Currently 5 operations are supported: exponentiation, multiplication,
         * addition, division and subtraction.
         */
        exponentiation(0, "pow", "pow, exponentiation, exp,^", "^"), multiplication(1, "multiply", "multiply, multiplication, *", "*"), addition(2, "add", "add, addition, +", "+"), division(3, "divide", "divide, division, /", "/"), subtraction(4, "subtract", "subtract, subtraction, -", "-");

        private int integerValue = -1;
        private String method = null;
        private String alternateNames = null;
        private String printName = null;

        /**
         * This is a basic constructor that initializes enum based on it's order
         * of operation value, BigInteger method name, alternative name and
         * printName.
         * 
         * @param Order
         *            or operation (Integer)
         * @param BigInteger
         *            method name (String)
         * @param Alternative
         *            names (String)
         * @param Print
         *            name (String)
         * @return None
         */
        private Type(int value, String method, String alternateNames, String printName) {
            this.integerValue = value;
            this.method = method;
            this.alternateNames = alternateNames;
            this.printName = printName;
        }

        /**
         * This method call suppressException to evaluate an expression and then
         * casts the result to BigInteger (safe cast).
         * 
         * @param BigInteger
         *            (first number in expression)
         * @param BigInteger
         *            (second number in expression)
         * @return BigInteger result
         */
        public BigInteger evaluateExpression(BigInteger value1, BigInteger value2) {
            return (BigInteger) suppressException(method, value1, value2);
        }

        /**
         * This method suppresses reflection exception and then invokes a
         * respective BigInteger method.
         * 
         * @param String
         *            representation of BigInteger method
         * @param BigInteger
         *            (first number in expression)
         * @param BigInteger
         *            (second number in expression)
         * @return BigInteger result
         */
        private static Object suppressException(String str, BigInteger value1, BigInteger value2) {
            try {
                Method method = value1.getClass().getMethod(str, str.equals("pow") ? int.class : BigInteger.class);

                return (str.equals("pow")) ? method.invoke(value1, value2.intValue()) : method.invoke(value1, value2);

            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        }

        /**
         * This method converts a String representation of a supported Type to a
         * Type object.
         * 
         * @param String
         *            representation of a supported Type
         * @return Type object
         */
        public static Type resolveType(String str) {
            for (Type type : Type.class.getEnumConstants()) {
                if (type.alternateNames.contains(str)) {
                    return type;
                }
            }
            return null;
        }

    }

    private Type value;

    /**
     * This is a basic constructor (private) that initializes Operation object
     * using a Type enum. Use getOperation method to initialize / get a
     * Operation object.
     * 
     * @param Type
     *            enum
     * @return None
     */
    private Operation(Type value) {
        super();
        this.value = value;
    }

    /**
     * Overridden hashCode method auto generated by eclipse IDE.
     * 
     * @param None
     * @return Hash value
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((value == null) ? 0 : value.hashCode());
        return result;
    }

    /**
     * Overridden equals method auto generated by eclipse IDE.
     * 
     * @param Operation
     *            object
     * @return Boolean equality
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Operation other = (Operation) obj;
        if (value != other.value)
            return false;
        return true;
    }

    /**
     * Overridden toString method auto generated by eclipse IDE.
     * 
     * @param None
     * @return String representation value
     */
    @Override
    public String toString() {
        return value.printName;
    }

    /**
     * This method returns integer value of the Type of Operation.
     * 
     * @param None
     * @return Integer order of operation of the Type
     */
    public int intValue() {
        return value.integerValue;
    }

    /**
     * This method returns evaluates an expression using two BigInteger values.
     * 
     * @param Two
     *            BigInteger values to be used to evaluate an expression
     * @return Resulting expression value
     */
    public BigInteger evaluateExpression(BigInteger value1, BigInteger value2) {
        try {
            return value.evaluateExpression(value1, value2);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * This method returns Operations that matches one of supported Operations'
     * printName.
     * 
     * @param String
     *            representation of one of supported Operations
     * @return Operation object
     */
    public static Operation getOperation(String value) {
        return new Operation(Type.resolveType(value.replaceAll(" ", "").toLowerCase()));
    }

    /**
     * This method returns number of supported Operations.
     * 
     * @param None
     * @return Integer count of supported operations
     */
    public static int countOfTypes() {
        return Type.class.getEnumConstants().length;
    }

    /**
     * This method returns String containing printNames of all supported
     * Operations.
     * 
     * @param None
     * @return String representation of all supported Operations
     */
    public static String getOperationPrintNames() {
        String str = "";
        for (Type type : Type.class.getEnumConstants()) {
            str += type.printName;
        }

        return str;
    }

    /**
     * This method checks if there is printName of one of the Types in given
     * String. If yes, it returns the index of printName. Else, it returns -1.
     * 
     * @param String
     * @return Index of printName of one of Types in given String
     */
    public static int existPrintName(String str) {
        int index = -1;

        for (Type type : Type.class.getEnumConstants()) {
            if (str.indexOf(type.printName) > -1) {
                return str.indexOf(type.printName);
            }
        }

        return index;
    }
}
